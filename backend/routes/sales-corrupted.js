const express = require('express');const router = express.Router();// Get all sales for a tenantrouter.get('/', async (req, res) => {  try {    const { page = 1, limit = 10, startDate, endDate } = req.query;    const offset = (page - 1) * limit;    const tenantId = req.tenantId;    let query = req.supabase      .from('sales')      .select(`        sale_id,        tenant_id,        product_id,        user_id,        quantity,        selling_price,        discount,        location,        created_at,        products:product_id (          name,          brand,          image_url        )      `, { count: 'exact' })      .eq('tenant_id', tenantId);    // Add date filters    if (startDate) {      query = query.gte('created_at', startDate);    }    if (endDate) {      query = query.lte('created_at', endDate);    }    // Add pagination    query = query      .range(offset, offset + limit - 1)      .order('created_at', { ascending: false });    const { data, error, count } = await query;    if (error) {      throw error;    }    res.json({      success: true,      data: data || [],      pagination: {        page: parseInt(page),        limit: parseInt(limit),        total: count,        totalPages: Math.ceil(count / limit)      },      tenant: req.tenant.org_name    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Failed to fetch sales',      error: error.message    });  }});// Get a specific sale for a tenantrouter.get('/:saleId', async (req, res) => {  try {    const { saleId } = req.params;    const tenantId = req.tenantId;    const { data, error } = await req.supabase      .from('sales')      .select(`        *,        products:product_id (          name,          brand,          purchase_price,          mrp        )      `)      .eq('sale_id', saleId)      .eq('tenant_id', tenantId)      .single();    if (error) {      throw error;    }    if (!data) {      return res.status(404).json({        success: false,        message: 'Sale not found'      });    }    res.json({      success: true,      data    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Failed to fetch sale',      error: error.message    });  }});// Create a new sale for a tenantrouter.post('/', async (req, res) => {  try {    const {      product_id,      user_id,      quantity,      selling_price,      discount = 0,      location    } = req.body;    const tenantId = req.tenantId;    // Validate required fields    if (!product_id || !user_id || !quantity || selling_price === undefined) {      return res.status(400).json({        success: false,        message: 'Missing required fields: product_id, user_id, quantity, selling_price'      });    }    // Verify the product exists and belongs to this tenant    const { data: product, error: productError } = await req.supabase      .from('products')      .select('product_id, name, brand')      .eq('product_id', product_id)      .eq('tenant_id', tenantId)      .single();    if (productError || !product) {      return res.status(404).json({        success: false,        message: 'Product not found'      });    }    // Verify the user exists and belongs to this tenant    const { data: user, error: userError } = await req.supabase      .from('users')      .select('user_id, name')      .eq('user_id', user_id)      .eq('tenant_id', tenantId)      .single();    if (userError || !user) {      return res.status(404).json({        success: false,        message: 'User not found'      });    }    // Check inventory availability if location is specified    if (location) {      const { data: inventory, error: inventoryError } = await req.supabase        .from('inventory')        .select('quantity')        .eq('tenant_id', tenantId)        .eq('product_id', product_id)        .eq('location', location)        .single();      if (inventoryError || !inventory) {        return res.status(400).json({          success: false,          message: 'Product not available at specified location'        });      }      if (inventory.quantity < quantity) {        return res.status(400).json({          success: false,          message: `Insufficient inventory. Available: ${inventory.quantity}, Requested: ${quantity}`        });      }    }    // Create the sale    const { data: sale, error: saleError } = await req.supabase      .from('sales')      .insert({        tenant_id: tenantId,        product_id,        user_id,        quantity: parseInt(quantity),        selling_price: parseFloat(selling_price),        discount: parseFloat(discount) || 0,        location: location || null,        created_at: new Date().toISOString()      })      .select()      .single();    if (saleError) {      throw saleError;    }    // Update inventory if location is specified    if (location) {      const { error: inventoryUpdateError } = await req.supabase        .rpc('decrement_inventory', {          p_tenant_id: tenantId,          p_product_id: product_id,          p_location: location,          p_quantity: quantity        });      if (inventoryUpdateError) {        console.error('Failed to update inventory after sale:', inventoryUpdateError);      }    }    res.status(201).json({      success: true,      message: 'Sale created successfully',      data: {        ...sale,        product: product,        user: user      }    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Failed to create sale',      error: error.message    });  }});// Get sales analytics for a tenantrouter.get('/analytics/summary', async (req, res) => {  try {    const { startDate, endDate } = req.query;    const tenantId = req.tenantId;    let query = req.supabase      .from('sales')      .select(`        quantity,        selling_price,        discount,        created_at,        products:product_id (          purchase_price        )      `)      .eq('tenant_id', tenantId);    // Add date filters    if (startDate) {      query = query.gte('created_at', startDate);    }    if (endDate) {      query = query.lte('created_at', endDate);    }    query = query.order('created_at', { ascending: false });    const { data, error } = await query;    if (error) {      throw error;    }    // Calculate analytics    const totalSales = data.length;    const totalRevenue = data.reduce((sum, sale) => {      return sum + ((sale.selling_price - sale.discount) * sale.quantity);    }, 0);        const totalCost = data.reduce((sum, sale) => {      const purchasePrice = sale.products?.purchase_price || 0;      return sum + (purchasePrice * sale.quantity);    }, 0);        const totalProfit = totalRevenue - totalCost;    const totalQuantitySold = data.reduce((sum, sale) => sum + sale.quantity, 0);    res.json({      success: true,      data: {        totalSales,        totalRevenue: Math.round(totalRevenue * 100) / 100,        totalCost: Math.round(totalCost * 100) / 100,        totalProfit: Math.round(totalProfit * 100) / 100,        totalQuantitySold,        averageSaleValue: totalSales > 0 ? Math.round((totalRevenue / totalSales) * 100) / 100 : 0      }    });  } catch (error) {    res.status(500).json({      success: false,      message: 'Failed to fetch sales analytics',      error: error.message    });  }});module.exports = router;